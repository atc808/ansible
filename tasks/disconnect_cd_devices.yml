---
- name: Filter VMs for disconnect operations
  ansible.builtin.set_fact:
    vms_eligible_for_disconnect: >-
      {{
        vms_with_cd_media |
        rejectattr('vm_name', 'in', vm_blacklist) |
        selectattr('cd_devices', 'defined') |
        list
      }}

- name: Calculate disconnect statistics
  ansible.builtin.set_fact:
    all_cd_devices: >-
      {{
        vms_eligible_for_disconnect |
        map(attribute='cd_devices') |
        flatten
      }}
    hot_removable_devices: >-
      {{
        vms_eligible_for_disconnect |
        map(attribute='cd_devices') |
        flatten |
        selectattr('hot_removable', 'equalto', true) |
        list
      }}
    manual_intervention_devices: >-
      {{
        vms_eligible_for_disconnect |
        map(attribute='cd_devices') |
        flatten |
        selectattr('hot_removable', 'equalto', false) |
        list
      }}

- name: Display dry-run information
  ansible.builtin.debug:
    msg: |
      ===================================================
      DRY RUN MODE - NO CHANGES WILL BE MADE
      ===================================================
      VMs that would be processed: {{ vms_eligible_for_disconnect | length }}
      Hot-removable devices that would be disconnected: {{ hot_removable_devices | length }}
      Devices requiring manual intervention: {{ manual_intervention_devices | length }}
      
      Hot-removable devices:
      {% for vm in vms_eligible_for_disconnect %}
      {% for cd in vm.cd_devices %}
      {% if cd.hot_removable %}
      - {{ vm.vm_name }}: {{ cd.device_label }} ({{ cd.media_path }})
      {% endif %}
      {% endfor %}
      {% endfor %}
      ===================================================
  when: dry_run | bool

- name: Debug - Check if disconnect operations should run
  ansible.builtin.debug:
    msg: |
      ===================================================
      DISCONNECT DEBUG INFORMATION:
      ===================================================
      dry_run: {{ dry_run }}
      disconnect: {{ disconnect }}
      vms_eligible_for_disconnect count: {{ vms_eligible_for_disconnect | length }}
      
      {% if vms_eligible_for_disconnect | length > 0 %}
      Eligible VMs:
      {% for vm in vms_eligible_for_disconnect %}
      - VM: {{ vm.vm_name }}
        CD devices: {{ vm.cd_devices | length }}
        Hot removable devices: {{ vm.cd_devices | selectattr('hot_removable', 'equalto', true) | list | length }}
      {% endfor %}
      {% endif %}
      ===================================================

- name: Debug - Check each VM/device combination
  ansible.builtin.debug:
    msg: |
      VM: {{ item.0.vm_name }}
      Device: {{ item.1.device_label }}
      Hot Removable: {{ item.1.hot_removable }}
      Will Process: {{ not (dry_run | bool) and item.1.hot_removable | bool }}
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"

- name: Check Python and PyVmomi availability
  ansible.builtin.command:
    cmd: python3 -c "import sys; import ssl; from pyVim.connect import SmartConnect; print('PyVmomi available')"
  delegate_to: localhost
  register: python_check
  failed_when: false
  run_once: true

- name: Display Python check results
  ansible.builtin.debug:
    msg: |
      Python/PyVmomi Check:
      Return Code: {{ python_check.rc }}
      Output: {{ python_check.stdout | default('No output') }}
      Error: {{ python_check.stderr | default('No errors') }}
  run_once: true

- name: Create Python script for CD media disconnection
  ansible.builtin.copy:
    content: |
      #!/usr/bin/env python3
      """
      VMware CD/DVD Media Disconnect Script
      Uses PyVmomi to disconnect CD media without confirmation dialogs
      """
      import sys
      import ssl
      import json
      from pyVim.connect import SmartConnect, Disconnect
      from pyVmomi import vim
      import atexit

      def disconnect_cd_media(host, username, password, vm_uuid, device_key):
          """
          Disconnect CD/DVD media from a specific VM device
          """
          result = {
              'success': False,
              'message': '',
              'error': '',
              'vm_found': False,
              'device_found': False,
              'media_was_connected': False
          }
          
          try:
              # Create SSL context that ignores certificate errors
              context = ssl.create_default_context()
              context.check_hostname = False
              context.verify_mode = ssl.CERT_NONE
              
              # Connect to vCenter/ESXi
              si = SmartConnect(
                  host=host,
                  user=username,
                  pwd=password,
                  sslContext=context
              )
              
              # Ensure we disconnect on exit
              atexit.register(Disconnect, si)
              
              # Get the content object
              content = si.RetrieveContent()
              
              # Find VM by UUID
              vm = None
              container = content.viewManager.CreateContainerView(
                  content.rootFolder, [vim.VirtualMachine], True
              )
              
              for managed_object in container.view:
                  if managed_object.config.uuid == vm_uuid:
                      vm = managed_object
                      break
              
              container.Destroy()
              
              if not vm:
                  result['error'] = f'VM not found with UUID: {vm_uuid}'
                  return result
              
              result['vm_found'] = True
              result['message'] += f'Found VM: {vm.name}\n'
              
              # Find the CD/DVD device
              cd_device = None
              for device in vm.config.hardware.device:
                  if hasattr(device, 'key') and device.key == int(device_key):
                      if isinstance(device, vim.vm.device.VirtualCdrom):
                          cd_device = device
                          break
              
              if not cd_device:
                  result['error'] = f'CD/DVD device not found with key: {device_key}'
                  return result
              
              result['device_found'] = True
              result['message'] += f'Found CD/DVD device: {cd_device.deviceInfo.label}\n'
              
              # Check if media is currently connected
              has_media = False
              if hasattr(cd_device, 'backing'):
                  if isinstance(cd_device.backing, vim.vm.device.VirtualCdrom.IsoBackingInfo):
                      if cd_device.backing.fileName:
                          has_media = True
                          result['message'] += f'Current ISO: {cd_device.backing.fileName}\n'
                  elif isinstance(cd_device.backing, vim.vm.device.VirtualCdrom.AtapiBackingInfo):
                      if cd_device.backing.deviceName:
                          has_media = True
                          result['message'] += f'Current device: {cd_device.backing.deviceName}\n'
              
              if cd_device.connectable and cd_device.connectable.connected:
                  has_media = True
                  result['message'] += 'Device is currently connected\n'
              
              result['media_was_connected'] = has_media
              
              if not has_media:
                  result['success'] = True
                  result['message'] += 'No media was connected - nothing to disconnect'
                  return result
              
              # Create a copy of the existing device for modification
              device_change = vim.vm.device.VirtualDeviceSpec()
              device_change.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
              
              # Clone the existing device
              new_device = vim.vm.device.VirtualCdrom()
              new_device.key = cd_device.key
              new_device.deviceInfo = cd_device.deviceInfo
              new_device.controllerKey = cd_device.controllerKey
              new_device.unitNumber = cd_device.unitNumber
              
              # Set to no media backing
              new_device.backing = vim.vm.device.VirtualCdrom.RemotePassthroughBackingInfo()
              
              # Create connectable device settings
              new_device.connectable = vim.vm.device.VirtualDevice.ConnectableDevice()
              new_device.connectable.connected = False
              new_device.connectable.startConnected = False
              new_device.connectable.allowGuestControl = True
              
              device_change.device = new_device
              
              # Create VM config spec
              config_spec = vim.vm.ConfigSpec()
              config_spec.deviceChange = [device_change]
              
              # Apply the configuration
              task = vm.ReconfigVM_Task(config_spec)
              
              # Wait for task completion
              while task.info.state in [vim.TaskInfo.State.running, vim.TaskInfo.State.queued]:
                  pass
              
              if task.info.state == vim.TaskInfo.State.success:
                  result['success'] = True
                  result['message'] += 'Successfully disconnected CD/DVD media'
              else:
                  result['error'] = f'Task failed: {task.info.error.localizedMessage if task.info.error else "Unknown error"}'
              
          except Exception as e:
              result['error'] = f'Exception occurred: {str(e)}'
          
          return result

      if __name__ == '__main__':
          if len(sys.argv) != 6:
              print('Usage: script.py <host> <username> <password> <vm_uuid> <device_key>')
              sys.exit(1)
          
          host = sys.argv[1]
          username = sys.argv[2] 
          password = sys.argv[3]
          vm_uuid = sys.argv[4]
          device_key = sys.argv[5]
          
          result = disconnect_cd_media(host, username, password, vm_uuid, device_key)
          print(json.dumps(result, indent=2))
          
          sys.exit(0 if result['success'] else 1)
    dest: /tmp/disconnect_cd_media.py
    mode: '0755'
  delegate_to: localhost
  run_once: true

- name: Test Python script execution (dry run)
  ansible.builtin.command:
    cmd: python3 /tmp/disconnect_cd_media.py
  delegate_to: localhost
  register: script_test
  failed_when: false
  run_once: true

- name: Display script test results
  ansible.builtin.debug:
    msg: |
      Script Test Results:
      Return Code: {{ script_test.rc }}
      Output: {{ script_test.stdout | default('No output') }}
      Error: {{ script_test.stderr | default('No errors') }}
  run_once: true

- name: Debug - About to execute disconnect command
  ansible.builtin.debug:
    msg: |
      Executing disconnect for:
      VM: {{ item.0.vm_name }}
      Device: {{ item.1.device_label }}
      UUID: {{ item.0.uuid }}
      Device Key: {{ item.1.device_key }}
      Command: python3 /tmp/disconnect_cd_media.py "{{ inventory_hostname }}" "{{ vcenter_username }}" "REDACTED" "{{ item.0.uuid }}" "{{ item.1.device_key }}"
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"
  when: 
    - not (dry_run | bool)
    - item.1.hot_removable | bool

- name: Disconnect CD media using VMware REST API
  ansible.builtin.uri:
    url: "https://{{ inventory_hostname }}/rest/vcenter/vm/{{ item.0.uuid }}/hardware/cdrom/{{ item.1.device_key }}"
    method: PATCH
    user: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    force_basic_auth: yes
    validate_certs: false
    body_format: json
    body:
      spec:
        backing:
          type: "NONE"
        start_connected: false
        allow_guest_control: true
    headers:
      Content-Type: "application/json"
    status_code: [200, 204]
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"
  delegate_to: localhost
  when: 
    - not (dry_run | bool)
    - item.1.hot_removable | bool
  register: vmware_api_results
  failed_when: false

- name: Debug parsed results structure (for troubleshooting)
  ansible.builtin.debug:
    msg: |
      Parsed Results Debug:
      - Results defined: {{ python_disconnect_results is defined }}
      - Number of results: {{ python_disconnect_results.results | default([]) | length }}
      {% if python_disconnect_results.results | default([]) | length > 0 %}
      - First result structure: {{ python_disconnect_results.results[0] | default('No results') }}
      {% endif %}
  when: 
    - not (dry_run | bool)
    - python_disconnect_results is defined

- name: Debug API results structure (for troubleshooting)
  ansible.builtin.debug:
    msg: |
      API Results Debug:
      - Results defined: {{ vmware_api_results is defined }}
      - Number of results: {{ vmware_api_results.results | default([]) | length }}
      {% if vmware_api_results.results | default([]) | length > 0 %}
      - First result structure: {{ vmware_api_results.results[0] | default('No results') }}
      {% endif %}
  when: 
    - not (dry_run | bool)
    - vmware_api_results is defined

- name: Parse VMware API results
  ansible.builtin.set_fact:
    parsed_results: []

- name: Parse each VMware API result
  ansible.builtin.set_fact:
    parsed_results: >-
      {{
        parsed_results + [{
          'item': item.item,
          'changed': item.status_code in [200, 204] if item.status_code is defined else false,
          'failed': item.failed | default(false),
          'operation_success': (item.status_code in [200, 204] if item.status_code is defined else false) and not (item.failed | default(false)),
          'status_code': item.status_code | default(0),
          'error_msg': item.msg | default('') if (item.failed | default(false)) else '',
          'result_type': 'vmware_api'
        }]
      }}
  loop: "{{ vmware_api_results.results | default([]) }}"
  when: 
    - not (dry_run | bool)
    - vmware_api_results is defined

- name: Report VMware API disconnect results
  ansible.builtin.debug:
    msg: |
      ===================================================
      CD DISCONNECT RESULT:
      ===================================================
      VM: {{ item.item.0.vm_name | default('Unknown VM') }}
      Device: {{ item.item.1.device_label | default('Unknown Device') }}
      Media Path: {{ item.item.1.media_path | default('N/A') }}
      Hot Removable: {{ item.item.1.hot_removable | default('Unknown') }}
      Controller/Unit: {{ item.item.1.controller_number }}/{{ item.item.1.unit_number }}
      Device Key: {{ item.item.1.device_key }}
      
      Result: {{ 'SUCCESS' if item.operation_success else 'FAILED' }}
      Status Code: {{ item.status_code | default('N/A') }}
      
      {% if item.failed is defined and item.failed %}
      Error Details:
      {{ item.error_msg | indent(2) }}
      {% elif item.operation_success %}
      CD/DVD media successfully disconnected via REST API!
      {% else %}
      Operation completed but result unclear
      {% endif %}
      ===================================================
  loop: "{{ parsed_results | default([]) }}"
  when: 
    - not (dry_run | bool)
    - parsed_results is defined

- name: Report devices requiring manual intervention
  ansible.builtin.debug:
    msg: |
      ===================================================
      MANUAL INTERVENTION REQUIRED:
      ===================================================
      VM: {{ item.0.vm_name }}
      Device: {{ item.1.device_label }}
      Controller: {{ item.1.controller_type }}
      Media: {{ item.1.media_path }}
      Device Key: {{ item.1.device_key }}
      
      This device cannot be hot-removed. Options:
      1. Use vSphere Client to manually disconnect
      2. Power off the VM and retry this playbook  
      3. Edit VM settings and remove the CD/DVD drive
      ===================================================
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"
  when: not (item.1.hot_removable | bool)

- name: Create summary of disconnect operations
  ansible.builtin.set_fact:
    successful_disconnects: >-
      {{
        parsed_results | default([]) |
        selectattr('operation_success', 'defined') |
        selectattr('operation_success', 'equalto', true) |
        selectattr('changed', 'equalto', true) |
        list
      }}
    failed_disconnects: >-
      {{
        parsed_results | default([]) |
        selectattr('operation_success', 'defined') |
        selectattr('operation_success', 'equalto', false) |
        list
      }}
    no_change_needed: >-
      {{
        parsed_results | default([]) |
        selectattr('operation_success', 'defined') |
        selectattr('operation_success', 'equalto', true) |
        selectattr('changed', 'equalto', false) |
        list
      }}

- name: Update disconnect results for summary reporting
  ansible.builtin.set_fact:
    disconnect_results:
      results: "{{ parsed_results | default([]) }}"
      successful_count: "{{ successful_disconnects | default([]) | length }}"
      failed_count: "{{ failed_disconnects | default([]) | length }}"
      no_change_count: "{{ no_change_needed | default([]) | length }}"
      total_processed: "{{ parsed_results | default([]) | length }}"
  when: parsed_results is defined

- name: Display disconnect operation summary
  ansible.builtin.debug:
    msg: |
      ===================================================
      DISCONNECT OPERATIONS SUMMARY:
      ===================================================
      Total devices processed: {{ disconnect_results.total_processed | default(0) }}
      Successful disconnections: {{ disconnect_results.successful_count | default(0) }}
      No changes needed: {{ disconnect_results.no_change_count | default(0) }}
      Failed operations: {{ disconnect_results.failed_count | default(0) }}
      Manual intervention required: {{ manual_intervention_devices | length }}
      ===================================================
  when: 
    - not (dry_run | bool)
    - disconnect_results is defined