---
- name: Filter VMs for disconnect operations
  ansible.builtin.set_fact:
    vms_eligible_for_disconnect: >-
      {{
        vms_with_cd_media |
        rejectattr('vm_name', 'in', vm_blacklist) |
        selectattr('cd_devices', 'defined') |
        list
      }}

- name: Calculate disconnect statistics
  ansible.builtin.set_fact:
    all_cd_devices: >-
      {{
        vms_eligible_for_disconnect |
        map(attribute='cd_devices') |
        flatten
      }}
    hot_removable_devices: >-
      {{
        vms_eligible_for_disconnect |
        map(attribute='cd_devices') |
        flatten |
        selectattr('hot_removable', 'equalto', true) |
        list
      }}
    manual_intervention_devices: >-
      {{
        vms_eligible_for_disconnect |
        map(attribute='cd_devices') |
        flatten |
        selectattr('hot_removable', 'equalto', false) |
        list
      }}

- name: Display dry-run information
  ansible.builtin.debug:
    msg: |
      ===================================================
      DRY RUN MODE - NO CHANGES WILL BE MADE
      ===================================================
      VMs that would be processed: {{ vms_eligible_for_disconnect | length }}
      Hot-removable devices that would be disconnected: {{ hot_removable_devices | length }}
      Devices requiring manual intervention: {{ manual_intervention_devices | length }}
      
      Hot-removable devices:
      {% for vm in vms_eligible_for_disconnect %}
      {% for cd in vm.cd_devices %}
      {% if cd.hot_removable %}
      - {{ vm.vm_name }}: {{ cd.device_label }} ({{ cd.media_path }})
      {% endif %}
      {% endfor %}
      {% endfor %}
      ===================================================
  when: dry_run | bool

- name: Debug - Check if disconnect operations should run
  ansible.builtin.debug:
    msg: |
      ===================================================
      DISCONNECT DEBUG INFORMATION:
      ===================================================
      dry_run: {{ dry_run }}
      disconnect: {{ disconnect }}
      vms_eligible_for_disconnect count: {{ vms_eligible_for_disconnect | length }}
      
      {% if vms_eligible_for_disconnect | length > 0 %}
      Eligible VMs:
      {% for vm in vms_eligible_for_disconnect %}
      - VM: {{ vm.vm_name }}
        CD devices: {{ vm.cd_devices | length }}
        Hot removable devices: {{ vm.cd_devices | selectattr('hot_removable', 'equalto', true) | list | length }}
      {% endfor %}
      {% endif %}
      ===================================================

- name: Debug - Check each VM/device combination
  ansible.builtin.debug:
    msg: |
      VM: {{ item.0.vm_name }}
      Device: {{ item.1.device_label }}
      Hot Removable: {{ item.1.hot_removable }}
      Will Process: {{ not (dry_run | bool) and item.1.hot_removable | bool }}
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"

- name: Check Python and PyVmomi availability
  ansible.builtin.command:
    cmd: python3 -c "import sys; import ssl; from pyVim.connect import SmartConnect; print('PyVmomi available')"
  delegate_to: localhost
  register: python_check
  failed_when: false
  run_once: true

- name: Display Python check results
  ansible.builtin.debug:
    msg: |
      Python/PyVmomi Check:
      Return Code: {{ python_check.rc }}
      Output: {{ python_check.stdout | default('No output') }}
      Error: {{ python_check.stderr | default('No errors') }}
  run_once: true

- name: Create Python script for CD media disconnection
  ansible.builtin.copy:
    content: |
      #!/usr/bin/env python3
      """
      VMware CD/DVD Media Disconnect Script
      Uses PyVmomi to disconnect CD media without confirmation dialogs
      """
      import sys
      import ssl
      import json
      from pyVim.connect import SmartConnect, Disconnect
      from pyVmomi import vim
      import atexit

      def disconnect_cd_media(host, username, password, vm_uuid, device_key):
          """
          Disconnect CD/DVD media from a specific VM device
          """
          result = {
              'success': False,
              'message': '',
              'error': '',
              'vm_found': False,
              'device_found': False,
              'media_was_connected': False
          }
          
          try:
              # Create SSL context that ignores certificate errors
              context = ssl.create_default_context()
              context.check_hostname = False
              context.verify_mode = ssl.CERT_NONE
              
              # Connect to vCenter/ESXi
              si = SmartConnect(
                  host=host,
                  user=username,
                  pwd=password,
                  sslContext=context
              )
              
              # Ensure we disconnect on exit
              atexit.register(Disconnect, si)
              
              # Get the content object
              content = si.RetrieveContent()
              
              # Find VM by UUID
              vm = None
              container = content.viewManager.CreateContainerView(
                  content.rootFolder, [vim.VirtualMachine], True
              )
              
              for managed_object in container.view:
                  if managed_object.config.uuid == vm_uuid:
                      vm = managed_object
                      break
              
              container.Destroy()
              
              if not vm:
                  result['error'] = f'VM not found with UUID: {vm_uuid}'
                  return result
              
              result['vm_found'] = True
              result['message'] += f'Found VM: {vm.name}\n'
              
              # Find the CD/DVD device
              cd_device = None
              for device in vm.config.hardware.device:
                  if hasattr(device, 'key') and device.key == int(device_key):
                      if isinstance(device, vim.vm.device.VirtualCdrom):
                          cd_device = device
                          break
              
              if not cd_device:
                  result['error'] = f'CD/DVD device not found with key: {device_key}'
                  return result
              
              result['device_found'] = True
              result['message'] += f'Found CD/DVD device: {cd_device.deviceInfo.label}\n'
              
              # Check if media is currently connected
              has_media = False
              if hasattr(cd_device, 'backing'):
                  if isinstance(cd_device.backing, vim.vm.device.VirtualCdrom.IsoBackingInfo):
                      if cd_device.backing.fileName:
                          has_media = True
                          result['message'] += f'Current ISO: {cd_device.backing.fileName}\n'
                  elif isinstance(cd_device.backing, vim.vm.device.VirtualCdrom.AtapiBackingInfo):
                      if cd_device.backing.deviceName:
                          has_media = True
                          result['message'] += f'Current device: {cd_device.backing.deviceName}\n'
              
              if cd_device.connectable and cd_device.connectable.connected:
                  has_media = True
                  result['message'] += 'Device is currently connected\n'
              
              result['media_was_connected'] = has_media
              
              if not has_media:
                  result['success'] = True
                  result['message'] += 'No media was connected - nothing to disconnect'
                  return result
              
              # Create device change spec to disconnect media
              device_change = vim.vm.device.VirtualDeviceSpec()
              device_change.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
              device_change.device = cd_device
              
              # Set to no media - create new backing without media
              device_change.device.backing = vim.vm.device.VirtualCdrom.RemotePassthroughBackingInfo()
              
              # Create new connectable device configuration
              connectable = vim.vm.device.VirtualDevice.ConnectableDevice()
              connectable.connected = False
              connectable.startConnected = False
              device_change.device.connectable = connectable
              
              # Create VM config spec
              config_spec = vim.vm.ConfigSpec()
              config_spec.deviceChange = [device_change]
              
              # Apply the configuration
              task = vm.ReconfigVM_Task(config_spec)
              
              # Wait for task completion
              while task.info.state in [vim.TaskInfo.State.running, vim.TaskInfo.State.queued]:
                  pass
              
              if task.info.state == vim.TaskInfo.State.success:
                  result['success'] = True
                  result['message'] += 'Successfully disconnected CD/DVD media'
              else:
                  result['error'] = f'Task failed: {task.info.error.localizedMessage if task.info.error else "Unknown error"}'
              
          except Exception as e:
              result['error'] = f'Exception occurred: {str(e)}'
          
          return result

      if __name__ == '__main__':
          if len(sys.argv) != 6:
              print('Usage: script.py <host> <username> <password> <vm_uuid> <device_key>')
              sys.exit(1)
          
          host = sys.argv[1]
          username = sys.argv[2] 
          password = sys.argv[3]
          vm_uuid = sys.argv[4]
          device_key = sys.argv[5]
          
          result = disconnect_cd_media(host, username, password, vm_uuid, device_key)
          print(json.dumps(result, indent=2))
          
          sys.exit(0 if result['success'] else 1)
    dest: /tmp/disconnect_cd_media.py
    mode: '0755'
  delegate_to: localhost
  run_once: true

- name: Test Python script execution (dry run)
  ansible.builtin.command:
    cmd: python3 /tmp/disconnect_cd_media.py
  delegate_to: localhost
  register: script_test
  failed_when: false
  run_once: true

- name: Display script test results
  ansible.builtin.debug:
    msg: |
      Script Test Results:
      Return Code: {{ script_test.rc }}
      Output: {{ script_test.stdout | default('No output') }}
      Error: {{ script_test.stderr | default('No errors') }}
  run_once: true

- name: Debug - About to execute disconnect command
  ansible.builtin.debug:
    msg: |
      Executing disconnect for:
      VM: {{ item.0.vm_name }}
      Device: {{ item.1.device_label }}
      UUID: {{ item.0.uuid }}
      Device Key: {{ item.1.device_key }}
      Command: python3 /tmp/disconnect_cd_media.py "{{ inventory_hostname }}" "{{ vcenter_username }}" "REDACTED" "{{ item.0.uuid }}" "{{ item.1.device_key }}"
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"
  when: 
    - not (dry_run | bool)
    - item.1.hot_removable | bool

- name: Disconnect CD devices using Python PyVmomi script
  ansible.builtin.command:
    cmd: >
      python3 /tmp/disconnect_cd_media.py
      "{{ inventory_hostname }}"
      "{{ vcenter_username }}"
      "{{ vcenter_password }}"
      "{{ item.0.uuid }}"
      "{{ item.1.device_key }}"
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"
  delegate_to: localhost
  when: 
    - not (dry_run | bool)
    - item.1.hot_removable | bool
  register: python_disconnect_results
  failed_when: false
  vars:
    ansible_command_timeout: 120

- name: Debug parsed results structure (for troubleshooting)
  ansible.builtin.debug:
    msg: |
      Parsed Results Debug:
      - Results defined: {{ python_disconnect_results is defined }}
      - Number of results: {{ python_disconnect_results.results | default([]) | length }}
      {% if python_disconnect_results.results | default([]) | length > 0 %}
      - First result structure: {{ python_disconnect_results.results[0] | default('No results') }}
      {% endif %}
  when: 
    - not (dry_run | bool)
    - python_disconnect_results is defined

- name: Parse Python script results with error handling
  ansible.builtin.set_fact:
    parsed_results: []

- name: Parse each result individually
  ansible.builtin.set_fact:
    parsed_results: >-
      {{
        parsed_results + [{
          'item': item.item,
          'rc': item.rc | default(-1),
          'stdout': item.stdout | default(''),
          'stderr': item.stderr | default(''),
          'operation_success': (item.rc | default(1)) == 0,
          'parsed_output': (item.stdout | default('{}') | from_json) if (item.stdout | default('') | length > 0) else {}
        }]
      }}
  loop: "{{ python_disconnect_results.results | default([]) }}"
  when: 
    - not (dry_run | bool)
    - python_disconnect_results is defined
  failed_when: false

- name: Report Python disconnect results
  ansible.builtin.debug:
    msg: |
      ===================================================
      CD DISCONNECT RESULT:
      ===================================================
      VM: {{ item.item.0.vm_name | default('Unknown VM') }}
      Device: {{ item.item.1.device_label | default('Unknown Device') }}
      Media Path: {{ item.item.1.media_path | default('N/A') }}
      Hot Removable: {{ item.item.1.hot_removable | default('Unknown') }}
      Return Code: {{ item.rc | default('N/A') }}
      Operation Success: {{ item.operation_success | default(false) }}
      
      {% if item.parsed_output is defined %}
      VM Found: {{ item.parsed_output.vm_found | default('Unknown') }}
      Device Found: {{ item.parsed_output.device_found | default('Unknown') }}
      Media Was Connected: {{ item.parsed_output.media_was_connected | default('Unknown') }}
      
      Result Details:
      {{ item.parsed_output.message | default('No message') | indent(2) }}
      
      {% if item.parsed_output.error is defined and item.parsed_output.error | length > 0 %}
      Error Details:
      {{ item.parsed_output.error | indent(2) }}
      {% endif %}
      {% else %}
      Raw Output:
      {{ item.stdout | default('No output available') | indent(2) }}
      {% if item.stderr is defined and item.stderr | length > 0 %}
      
      Errors:
      {{ item.stderr | indent(2) }}
      {% endif %}
      {% endif %}
      ===================================================
  loop: "{{ parsed_results | default([]) }}"
  when: 
    - not (dry_run | bool)
    - parsed_results is defined

- name: Report devices requiring manual intervention
  ansible.builtin.debug:
    msg: |
      ===================================================
      MANUAL INTERVENTION REQUIRED:
      ===================================================
      VM: {{ item.0.vm_name }}
      Device: {{ item.1.device_label }}
      Controller: {{ item.1.controller_type }}
      Media: {{ item.1.media_path }}
      Device Key: {{ item.1.device_key }}
      
      This device cannot be hot-removed. Options:
      1. Use vSphere Client to manually disconnect
      2. Power off the VM and retry this playbook  
      3. Edit VM settings and remove the CD/DVD drive
      ===================================================
  with_subelements:
    - "{{ vms_eligible_for_disconnect }}"
    - cd_devices
  loop_control:
    label: "{{ item.0.vm_name }} - {{ item.1.device_label }}"
  when: not (item.1.hot_removable | bool)

- name: Create summary of disconnect operations
  ansible.builtin.set_fact:
    successful_disconnects: >-
      {{
        parsed_results | default([]) |
        selectattr('operation_success', 'defined') |
        selectattr('operation_success', 'equalto', true) |
        list
      }}
    failed_disconnects: >-
      {{
        parsed_results | default([]) |
        selectattr('operation_success', 'defined') |
        selectattr('operation_success', 'equalto', false) |
        list
      }}
    already_disconnected: >-
      {{
        parsed_results | default([]) |
        selectattr('parsed_output', 'defined') |
        selectattr('parsed_output.media_was_connected', 'defined') |
        selectattr('parsed_output.media_was_connected', 'equalto', false) |
        list
      }}

- name: Update disconnect results for summary reporting
  ansible.builtin.set_fact:
    disconnect_results:
      results: "{{ parsed_results | default([]) }}"
      successful_count: "{{ successful_disconnects | default([]) | length }}"
      failed_count: "{{ failed_disconnects | default([]) | length }}"
      already_disconnected_count: "{{ already_disconnected | default([]) | length }}"
      total_processed: "{{ parsed_results | default([]) | length }}"
  when: parsed_results is defined

- name: Display disconnect operation summary
  ansible.builtin.debug:
    msg: |
      ===================================================
      DISCONNECT OPERATIONS SUMMARY:
      ===================================================
      Total devices processed: {{ disconnect_results.total_processed | default(0) }}
      Successful disconnections: {{ disconnect_results.successful_count | default(0) }}
      Already disconnected: {{ disconnect_results.already_disconnected_count | default(0) }}
      Failed operations: {{ disconnect_results.failed_count | default(0) }}
      Manual intervention required: {{ manual_intervention_devices | length }}
      ===================================================
  when: 
    - not (dry_run | bool)
    - disconnect_results is defined

- name: Clean up temporary Python script
  ansible.builtin.file:
    path: /tmp/disconnect_cd_media.py
    state: absent
  delegate_to: localhost
  run_once: true